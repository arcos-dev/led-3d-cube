<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>LED 3D Cube Visualizer for Wokwi</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: #0d1117;
      color: #c9d1d9;
      overflow: hidden;
    }
    #canvas { display: block; width: 100vw; height: 100vh; }
    #info {
      position: absolute;
      top: 70px;
      left: 20px;
      font-size: 12px;
      background: rgba(13, 17, 23, 0.9);
      padding: 15px;
      border-radius: 8px;
      border: 1px solid #30363d;
      max-width: 300px;
      backdrop-filter: blur(10px);
    }
    #info p { margin: 5px 0; }
    .label { color: #79c0ff; font-weight: bold; }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div id="info">
    <p><span class="label">ðŸŽ® LED 3D Cube</span></p>
    <p>Resolution: <span id="res">8Ã—8Ã—8 = 512 LEDs</span></p>
    <p>Active LEDs: <span id="activeLeds">0</span></p>
    <p>FPS: <span id="fps">0</span></p>
    <p style="margin-top: 10px; font-size: 11px; color: #8b949e;">
      Integrated with Wokwi Simulator
    </p>
  </div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@latest/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@latest/examples/jsm/"
    }
  }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

    // Configuration
    const CUBE_SIZE = 8;
    const LED_RADIUS = 0.38;
    const LED_SPACING = 2.0;
    const GRID_HALF = (CUBE_SIZE - 1) * LED_SPACING / 2;

    // ========== EFEITOS PWM E REALISMO AVANÃ‡ADO ==========
    class LEDRealism {
      constructor() {
        this.globalTime = 0;
        this.pwmFrequency = 4; // FrequÃªncia mais alta para efeito mais sutil
        this.updateInterval = 2; // Atualiza efeitos a cada 2 frames
        this.frameCounter = 0;
        // Cache de valores prÃ©-calculados (melhor resoluÃ§Ã£o)
        this.sinCache = new Float32Array(1024);
        for (let i = 0; i < 1024; i++) {
          this.sinCache[i] = Math.sin((i / 1024) * Math.PI * 2);
        }
      }

      // Lookup rÃ¡pido de seno usando cache
      fastSin(value) {
        const index = Math.floor((value % 1) * 1024);
        return this.sinCache[index < 0 ? index + 1024 : index];
      }

      // Simula efeito PWM realista com mÃºltiplas harmonicas
      applyPWMEffect(brightness, ledIndex, time) {
        // OscilaÃ§Ã£o principal
        const mainOsc = this.fastSin(ledIndex * 0.3 + time * this.pwmFrequency) * 0.5 + 0.5;

        // HarmÃ´nica secundÃ¡ria para textura
        const harmonic = this.fastSin(ledIndex * 0.7 + time * this.pwmFrequency * 2.3) * 0.2 + 0.8;

        // VariaÃ§Ã£o lenta para "respiraÃ§Ã£o"
        const breathing = this.fastSin(time * 0.6 + ledIndex * 0.1) * 0.15 + 0.85;

        // Combina todas as oscilaÃ§Ãµes
        const pwmEffect = (mainOsc * 0.6 + 0.4) * harmonic * breathing;

        return brightness * pwmEffect;
      }

      // OscilaÃ§Ã£o de cor mais rica e complexa
      oscillateHue(baseColor, ledIndex, time) {
        // OscilaÃ§Ãµes RGB independentes com diferentes frequÃªncias
        const rOsc = this.fastSin(ledIndex * 0.25 + time * 0.7) * 0.05;
        const gOsc = this.fastSin(ledIndex * 0.35 + time * 0.85) * 0.05;
        const bOsc = this.fastSin(ledIndex * 0.45 + time * 0.65) * 0.05;

        return {
          r: Math.max(0, Math.min(1, baseColor.r + rOsc)),
          g: Math.max(0, Math.min(1, baseColor.g + gOsc)),
          b: Math.max(0, Math.min(1, baseColor.b + bOsc))
        };
      }

      // Aplica realismo avanÃ§ado com variaÃ§Ãµes sutis
      applyRealisticLED(brightness, color, ledIndex, time) {
        const pwmBrightness = this.applyPWMEffect(brightness, ledIndex, time);
        const oscillatedColor = this.oscillateHue(color, ledIndex, time);

        // PulsaÃ§Ã£o suave para simular variaÃ§Ãµes de corrente
        const pulsation = this.fastSin(time * 1.2 + ledIndex * 0.15) * 0.12 + 0.88;

        // Shimmer sutil (brilho ocasional)
        const shimmer = this.fastSin(time * 3.5 + ledIndex * 0.8) * 0.08 + 0.92;

        const finalBrightness = pwmBrightness * pulsation * shimmer;

        return {
          color: oscillatedColor,
          brightness: finalBrightness,
          intensity: finalBrightness
        };
      }
    }

    const ledRealism = new LEDRealism();

    // Scene setup
    const canvas = document.getElementById('canvas');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0a0e14);
    scene.fog = new THREE.Fog(0x0a0e14, 100, 200);

    const camera = new THREE.PerspectiveCamera(
      60,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    camera.position.set(28, 28, 28);

    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, precision: 'highp', alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Limita pixel ratio
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Sombras suaves para realismo
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping; // Tone mapping cinematogrÃ¡fico
    renderer.toneMappingExposure = 1.2; // ExposiÃ§Ã£o ligeiramente aumentada

    // Post-processing (Bloom effect - enhanced)
    const composer = new EffectComposer(renderer);
    const renderPass = new RenderPass(scene, camera);
    composer.addPass(renderPass);

    const bloomPass = new UnrealBloomPass(
      new THREE.Vector2(window.innerWidth, window.innerHeight),
      2.5,  // strength - bloom muito mais intenso para realismo
      1.2,  // radius - maior para difusÃ£o realista da luz
      0.3   // threshold - muito mais sensÃ­vel para capturar luzes sutis
    );
    composer.addPass(bloomPass);

    // Enhanced Lighting for realistic LED display
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.2); // Reduzido para dar destaque aos LEDs
    scene.add(ambientLight);

    const pointLight = new THREE.PointLight(0xffffff, 1.8, 300);
    pointLight.position.set(40, 50, 40);
    pointLight.castShadow = true;
    pointLight.shadow.mapSize.width = 1024;
    pointLight.shadow.mapSize.height = 1024;
    pointLight.shadow.camera.far = 300;
    scene.add(pointLight);

    // Secondary fill light for better dimension
    const fillLight = new THREE.PointLight(0x6699ff, 0.8, 300);
    fillLight.position.set(-30, 20, -30);
    scene.add(fillLight);

    // Tertiary accent light
    const accentLight = new THREE.PointLight(0xff6699, 0.6, 250);
    accentLight.position.set(30, -20, -40);
    scene.add(accentLight);

    // Grid with better visibility
    const gridHelper = new THREE.GridHelper(CUBE_SIZE * 2.5, CUBE_SIZE * 2.5, 0x2d3748, 0x1a202c);
    gridHelper.position.y = -GRID_HALF - 2;
    scene.add(gridHelper);

    // Controls
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.08;
    controls.minDistance = 20;
    controls.maxDistance = 100;
    controls.autoRotate = true;
    controls.autoRotateSpeed = 1.5;

    // LED creation with ultra-realistic materials
    const leds = [];
    const tempColor = new THREE.Color();

    // Create LED geometry com mais qualidade para realismo
    const ledGeometry = new THREE.SphereGeometry(LED_RADIUS, 20, 20); // Mais segments para suavidade

    for (let i = 0; i < CUBE_SIZE * CUBE_SIZE * CUBE_SIZE; i++) {
      // Material ultra-realista: LED translÃºcido com especularidade
      const ledMaterial = new THREE.MeshStandardMaterial({
        color: 0x0a0a0a,
        emissive: 0x000000,
        emissiveIntensity: 0,
        metalness: 0.8,      // Mais metÃ¡lico para reflexos realistas
        roughness: 0.15,     // Muito polido para brilho intenso
        transparent: true,
        opacity: 0.95,       // Mais opaco para cores vibrantes
        toneMapped: true,
        side: THREE.DoubleSide,
        wireframe: false
      });

      const mesh = new THREE.Mesh(ledGeometry, ledMaterial);
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      mesh.userData = {
        targetColor: { r: 0, g: 0, b: 0 },
        currentColor: { r: 0, g: 0, b: 0 },
        displayColor: { r: 0, g: 0, b: 0 },
        material: ledMaterial,
        glow: null,
        glowMaterial: null,
        index: i,
        brightness: 0,
        targetBrightness: 0
      };

      // Glow mesh primÃ¡rio - halo prÃ³ximo
      const glowGeometry = new THREE.SphereGeometry(LED_RADIUS + 0.25, 16, 16);
      const glowMaterial = new THREE.MeshBasicMaterial({
        color: 0x000000,
        transparent: true,
        opacity: 0,
        fog: false,
        toneMapped: false,
        blending: THREE.AdditiveBlending // Blending aditivo para luz realista
      });
      const glowMesh = new THREE.Mesh(glowGeometry, glowMaterial);
      glowMesh.scale.z = 0.2;
      mesh.add(glowMesh);
      mesh.userData.glow = glowMesh;
      mesh.userData.glowMaterial = glowMaterial;

      // Secondary glow layer - difusÃ£o externa (halo maior)
      const glowGeometry2 = new THREE.SphereGeometry(LED_RADIUS + 0.5, 12, 12);
      const glowMaterial2 = new THREE.MeshBasicMaterial({
        color: 0x000000,
        transparent: true,
        opacity: 0,
        fog: false,
        toneMapped: false,
        blending: THREE.AdditiveBlending
      });
      const glowMesh2 = new THREE.Mesh(glowGeometry2, glowMaterial2);
      glowMesh2.scale.z = 0.1;
      mesh.add(glowMesh2);
      mesh.userData.glowLayer2 = { mesh: glowMesh2, material: glowMaterial2 };

      // Tertiary glow - difusÃ£o muito leve (atmosfera)
      const glowGeometry3 = new THREE.SphereGeometry(LED_RADIUS + 0.8, 10, 10);
      const glowMaterial3 = new THREE.MeshBasicMaterial({
        color: 0x000000,
        transparent: true,
        opacity: 0,
        fog: true,
        toneMapped: false,
        blending: THREE.AdditiveBlending
      });
      const glowMesh3 = new THREE.Mesh(glowGeometry3, glowMaterial3);
      glowMesh3.scale.z = 0.05;
      mesh.add(glowMesh3);
      mesh.userData.glowLayer3 = { mesh: glowMesh3, material: glowMaterial3 };

      const x = (i % CUBE_SIZE) * LED_SPACING - GRID_HALF;
      const y = Math.floor((i / CUBE_SIZE) % CUBE_SIZE) * LED_SPACING - GRID_HALF;
      const z = Math.floor(i / (CUBE_SIZE * CUBE_SIZE)) * LED_SPACING - GRID_HALF;

      mesh.position.set(x, y, z);
      scene.add(mesh);
      leds.push(mesh);
    }

    // Wokwi integration com detecÃ§Ã£o de timeout
    let activeLedCount = 0;
    let lastMessageTime = Date.now();
    let isWokwiConnected = false;
    const TIMEOUT_MS = 2000; // 2 segundos sem mensagem = desconectado

    function updateLEDs(neopixelData) {
      activeLedCount = 0;
      lastMessageTime = Date.now();
      isWokwiConnected = true;

      for (let i = 0; i < neopixelData.length && i < leds.length; i++) {
        const value = neopixelData[i];
        const r = (value >> 8) & 0xff;
        const g = (value >> 16) & 0xff;
        const b = value & 0xff;

        leds[i].userData.targetColor = { r: r / 255, g: g / 255, b: b / 255 };
        leds[i].userData.targetBrightness = Math.max(r, g, b) / 255;

        if (r > 0 || g > 0 || b > 0) activeLedCount++;
      }
    }

    function turnOffAllLEDs() {
      activeLedCount = 0;
      for (let i = 0; i < leds.length; i++) {
        leds[i].userData.targetColor = { r: 0, g: 0, b: 0 };
        leds[i].userData.targetBrightness = 0;
      }
    }

    function checkWokwiConnection() {
      const now = Date.now();
      if (isWokwiConnected && (now - lastMessageTime > TIMEOUT_MS)) {
        isWokwiConnected = false;
        turnOffAllLEDs();
        console.log('Wokwi connection lost - LEDs turned off');
      }
    }

    window.addEventListener('message', (event) => {
      if (event.data?.neopixels) {
        updateLEDs(event.data.neopixels);
      }
    });

    // Tell Wokwi we're ready
    if (window.parent !== window) {
      window.parent.postMessage({ app: 'wokwi', command: 'listen', version: 1 }, '*');
    }

    // Animation loop with PWM and realism effects
    let frameCount = 0;
    let lastTime = performance.now();
    let animationTime = 0;

    function animate() {
      requestAnimationFrame(animate);

      const currentTime = performance.now();
      if (currentTime >= lastTime + 1000) {
        document.getElementById('fps').textContent = frameCount;
        frameCount = 0;
        lastTime = currentTime;

        // Verifica conexÃ£o com Wokwi a cada segundo
        checkWokwiConnection();
      }
      frameCount++;

      // Update animation time
      animationTime += 0.016; // ~60 FPS

      // Update each LED with realistic effects - EFEITOS VISUAIS APRIMORADOS
      const transitionSpeed = 0.12; // TransiÃ§Ã£o mais suave para fluidez
      const ledsLength = leds.length;

      for (let i = 0; i < ledsLength; i++) {
        const led = leds[i];
        const userData = led.userData;
        const material = userData.material;
        const glow = userData.glow;
        const glowLayer2 = userData.glowLayer2;
        const glowLayer3 = userData.glowLayer3;

        // Smooth brightness interpolation
        const brightDiff = userData.targetBrightness - userData.brightness;
        userData.brightness += brightDiff * transitionSpeed;

        // Smooth color interpolation
        userData.currentColor.r += (userData.targetColor.r - userData.currentColor.r) * transitionSpeed;
        userData.currentColor.g += (userData.targetColor.g - userData.currentColor.g) * transitionSpeed;
        userData.currentColor.b += (userData.targetColor.b - userData.currentColor.b) * transitionSpeed;

        // Apply realistic LED effects (PWM + oscillation + pulsation)
        const realisticEffect = ledRealism.applyRealisticLED(
          userData.brightness,
          userData.currentColor,
          userData.index,
          animationTime
        );

        // Convert to Three.js color
        tempColor.setRGB(
          realisticEffect.color.r,
          realisticEffect.color.g,
          realisticEffect.color.b
        );

        // Update material properties com intensidade realista
        material.color.copy(tempColor);
        material.emissive.copy(tempColor);

        // Dynamic emissive intensity - muito mais intenso para realismo
        const intensity = realisticEffect.intensity;
        material.emissiveIntensity = intensity * 5.0; // Aumentado de 3.0 para 5.0
        material.opacity = 0.85 + (intensity * 0.15);

        // Metalness e roughness dinÃ¢micos para reflexos realistas
        material.metalness = 0.7 + (intensity * 0.3);
        material.roughness = 0.2 - (intensity * 0.15);

        // Update primary glow layer (halo prÃ³ximo intenso)
        if (intensity > 0.01) {
          glow.material.color.copy(tempColor);
          glow.material.opacity = intensity * 0.9; // Mais intenso
          const glowScale = 1 + (intensity * 0.6);
          glow.scale.set(glowScale, glowScale, glowScale);
        } else {
          glow.material.opacity = 0;
        }

        // Update secondary glow layer (difusÃ£o mÃ©dia)
        if (intensity > 0.05) {
          glowLayer2.material.color.copy(tempColor);
          glowLayer2.material.opacity = intensity * 0.5;
          const glowScale2 = 1 + (intensity * 0.8);
          glowLayer2.mesh.scale.set(glowScale2, glowScale2, glowScale2);
        } else {
          glowLayer2.material.opacity = 0;
        }

        // Update tertiary glow layer (atmosfera suave)
        if (intensity > 0.1) {
          glowLayer3.material.color.copy(tempColor);
          glowLayer3.material.opacity = intensity * 0.25;
          const glowScale3 = 1 + (intensity * 1.2);
          glowLayer3.mesh.scale.set(glowScale3, glowScale3, glowScale3);
        } else {
          glowLayer3.material.opacity = 0;
        }
      }

      document.getElementById('activeLeds').textContent = activeLedCount;

      controls.update();
      composer.render();
    }

    // Handle window resize
    window.addEventListener('resize', () => {
      const width = window.innerWidth;
      const height = window.innerHeight;
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
      renderer.setSize(width, height);
      composer.setSize(width, height);
    });

    animate();
  </script>
</body>
</html>
